# BIOS入門 - 生成AI執筆ガイドライン

このドキュメントは、Claude（生成AI）が本書を体系的に執筆するための計画書です。

---

## 📋 執筆の全体戦略

### 基本方針

1. **段階的執筆**: Part 0 → Part VI の順に執筆
2. **完全性**: 各章は独立して読めるが、前の章の知識を前提とする
3. **文章主体**: 文章による丁寧な説明を中心とし、図表は理解を助けるための補助として使用
4. **理解重視**: 目的・構成・仕組み・役割を文章で詳しく解説し、概念の理解を促進する
5. **初心者配慮**: 専門用語には必ず説明を添え、段落を使って丁寧に説明する

**重要**: 箇条書きや表、図は文章の理解を助けるための補助的なツールです。メインコンテンツは文章による説明であり、読者が段落を読むことで理解を深められるようにします。

### 執筆優先度

#### Phase 1: 基礎（必須） - 最優先
- Part 0（全体像の理解）
- Part I（x86_64 ブート基礎）
- Part II 前半（EDK II アーキテクチャ）

#### Phase 2: 詳細理解（重要）
- Part II 後半（各サブシステム）
- Part III（プラットフォーム初期化）

#### Phase 3: 発展（推奨）
- Part IV（セキュリティアーキテクチャ）
- Part V（デバッグ・最適化の原理）

#### Phase 4: 比較と展望（オプショナル）
- Part VI（他のファームウェア実装、ARM64、将来展望）

### 目標

- **最小構成**: Phase 1 完成で BIOS/UEFI の基本概念とブートプロセスを理解する
- **標準構成**: Phase 1-2 完成で EDK II アーキテクチャとプラットフォーム初期化の仕組みを理解する
- **完全版**: Phase 1-4 完成でプロフェッショナルレベルの知識と全体像を把握する

---

## 📖 章構成テンプレート

### 標準的な章の構成

```markdown
# 章タイトル

🎯 **この章で学ぶこと**
- 学習目標1
- 学習目標2
- 学習目標3

📚 **前提知識**
- 前提となる知識・章

---

## セクション1: 概要と目的

この章では〜について学びます。まず、なぜこの技術が必要なのかを理解することから始めましょう。

[文章による導入説明を2-4段落で記述]
[技術の背景、歴史的経緯、解決したい課題などを文章で説明]

## セクション2: 全体構成

〜の全体構成は、複数のコンポーネントから成り立っています。ここでは、各コンポーネントがどのような役割を持ち、どのように連携しているかを見ていきます。

[文章による全体像の説明を3-5段落で記述]
[各コンポーネントの位置づけと関係性を文章で丁寧に説明]

**補足図**: 以下の図は、上記で説明した全体構成を視覚的に示したものです。

```mermaid
[理解を助けるための図]
```

## セクション3: 動作原理と仕組み

次に、〜がどのように動作するのか、その内部メカニズムを詳しく見ていきましょう。

[文章による動作原理の説明を4-6段落で記述]
[処理の流れ、状態遷移、データの流れなどを文章で段階的に説明]

### 各コンポーネントの役割

各コンポーネントは特定の責務を持っています。ここでは、それぞれの役割を詳しく説明します。

[文章による各コンポーネントの説明を2-3段落ずつ記述]

## セクション4: 設計思想と背景

このような設計になっている理由を理解することは重要です。技術的な制約や歴史的な経緯から、なぜこのアーキテクチャが選ばれたのかを見ていきます。

[文章による設計思想の説明を3-5段落で記述]
[歴史的経緯、技術的制約、トレードオフなどを文章で説明]

## セクション5: 具体例（オプショナル）

理解を深めるために、具体的な例を見てみましょう。以下は、〜の概念を示すための簡略化されたコード例です。

```c
// 概念を示すための簡略化されたコード例
// 実際の実装は異なる場合があります
```

このコードでは〜を示しています。[コードの説明を2-3段落で記述]

## まとめ

この章では、〜について学びました。[文章で要約を2-3段落で記述]

重要なポイントは以下の通りです：
- 重要なポイント1（必要に応じて文章で補足）
- 重要なポイント2（必要に応じて文章で補足）
- 重要なポイント3（必要に応じて文章で補足）

次章では、〜について学びます。

---

📚 **参考資料**
- [UEFI仕様書 該当セクション](URL)
- [関連技術ドキュメント](URL)
```

### 執筆時の重要な注意事項

1. **文章を主体にする**: 各セクションは文章の段落で構成し、箇条書きは最小限にする
2. **段落で説明する**: 1つの概念を1-2段落（3-6文）で丁寧に説明する
3. **図表は補助**: 図表は「補足図」「参考表」として、文章の後に配置し、文章の理解を助ける役割に徹する
4. **箇条書きの制限**: 箇条書きは、まとめや列挙が必要な場合のみ使用する
5. **接続詞を活用**: 段落間の繋がりを意識し、「まず」「次に」「さらに」「したがって」などの接続詞を使う

### セクションの種類と使い分け

| アイコン | 用途 | 必須/任意 |
|---------|------|-----------|
| 🎯 | 学習目標 | 必須 |
| 📚 | 前提知識・参考資料 | 必須 |
| 🏗️ | 構成・アーキテクチャ | 推奨 |
| ⚙️ | 動作原理・メカニズム | 推奨 |
| 🔗 | 外部リンク | 任意 |
| ⚠️ | 警告・注意 | 必要に応じて |
| 💡 | Tips・豆知識 | 任意 |

### 引用ブロックの使い分け

```markdown
> **Note**: 補足説明や追加情報

> **Warning**: 注意事項や危険な操作

> **Tip**: 便利なテクニックやショートカット

> **Important**: 重要なポイント
```

---

## ✍️ 執筆ガイドライン

### トーン＆スタイル

1. **文章主体**: 箇条書きや表に頼らず、文章の段落で丁寧に説明する
2. **段落構成**: 1段落は3-6文で構成し、1つの概念を完結させる
3. **接続詞の活用**: 段落間の論理的な繋がりを明示する（まず、次に、さらに、したがって、など）
4. **明確性**: 曖昧な表現を避け、具体的に説明する（「多分」「恐らく」は使わない）
5. **親しみやすさ**: 堅苦しすぎず、初心者に優しい語調を保つ
6. **専門性**: 正確な技術用語を使用し、初出時に文章で説明を添える

### 文章の書き方ガイド

1. **導入部**: 各セクションの最初で、何について説明するかを明示する
   - 例: 「この章では、〜について学びます。」「次に、〜を見ていきましょう。」

2. **展開部**: 概念を段階的に説明し、各段落で1つのポイントを扱う
   - 例: 「まず、〜について説明します。」「これは〜という仕組みによって実現されています。」

3. **まとめ部**: セクションの終わりで、要点を再確認する
   - 例: 「以上のように、〜は〜という役割を持っています。」

4. **図表の導入**: 図表の前に必ず説明文を置き、図表が何を示すかを明示する
   - 例: 「以下の図は、上記で説明した〜を視覚的に示したものです。」

### 技術レベル設定

| Part | 対象レベル | 説明スタイル |
|------|----------|-------------|
| Part 0-I | 初心者 | 丁寧・具体的・図解多め |
| Part II | 中級者 | 概念的・構造理解中心・アーキテクチャ解説 |
| Part III-IV | 中級～上級 | 詳細・仕様準拠・設計思想の説明 |
| Part V-VI | 上級者 | 発展的トピック・比較分析 |

### 用語の統一ルール

| 用語 | 表記 | 備考 |
|------|------|------|
| UEFI | 大文字 | Unified Extensible Firmware Interface |
| BIOS | 大文字 | Basic Input/Output System |
| ブートローダ | カタカナ | bootloader |
| ファームウェア | カタカナ | firmware |
| プラットフォーム | カタカナ | platform |
| CPU | 大文字 | プロセッサでも可 |
| メモリ | カタカナ | RAM, DRAM は文脈により |
| x86_64 | 小文字+数字 | アーキテクチャ名 |

### コード例の方針

#### 基本的な考え方

コード例は**概念を理解するための補助**として使用します。完全に動作するコードである必要はなく、重要な部分を抽出・簡略化して示します。

#### コード例の要件

1. **目的明示**: コードの目的と示したい概念を明記
2. **簡潔性**: 理解に必要な部分のみを抽出（完全なコードは不要）
3. **コメント**: 重要な行に日本語コメントで説明
4. **スタイル**: 一貫したコーディングスタイル
   - インデント: 2スペース（C言語）
   - 変数名: CamelCase（UEFI準拠）
   - 関数名: CamelCase（UEFI準拠）

#### コード例テンプレート

```c
/**
  この例の目的: XXXの仕組みを理解する

  注: 実際の実装は異なる場合があります。
      概念を理解するための簡略化されたコードです。
**/

// 重要な処理の流れを示す
EFI_STATUS Status;

// ステップ1: 初期化
Status = InitializeComponent();

// ステップ2: 設定
Status = ConfigureComponent();

// ステップ3: 実行
Status = ExecuteOperation();
```

### 図表の方針（重要改訂）

**文章による説明が主体**です。図表は文章の理解を助けるための補助的なツールとして使用します。

#### 基本原則

1. **文章優先**: まず文章で丁寧に説明し、その理解を助けるために図表を使用する
2. **図表の位置**: 図表は必ず文章の説明の後に配置し、「補足図」「参考表」として提示する
3. **導入文必須**: 図表の前に必ず説明文を置き、何を示すかを明記する
   - 例: 「以下の図は、上記で説明した処理の流れを視覚的に示したものです。」
4. **図表の量**: 図表に頼りすぎず、必要最小限にとどめる（1セクションに0-1個程度）

#### 図表の使い分け

1. **Mermaid図**: 複雑な構造や流れを視覚化する必要がある場合のみ
   - 文章で説明が困難な場合の補助として使用

2. **表**: 多数の項目を比較する必要がある場合のみ
   - 2-3項目の比較なら文章で説明する

3. **ASCII art**: メモリレイアウトなど、視覚化が有効な場合のみ

4. **画像**: 原則として使用しない

#### 図表使用の判断基準

**図表を使うべき場合**:
- 複数のコンポーネント間の関係が複雑で、文章だけでは理解が困難
- 処理フローが5ステップ以上あり、視覚化が理解を助ける
- 5項目以上の比較が必要で、表形式が明確

**文章のみで説明すべき場合**:
- 単純な概念や定義
- 2-3項目の比較
- 順序だった処理（文章で「まず」「次に」で説明可能）
- 単一のコンポーネントの役割

#### Mermaid 例

```markdown
```mermaid
graph TB
    A[電源ON] --> B[SEC Phase<br/>セキュリティ初期化]
    B --> C[PEI Phase<br/>プラットフォーム初期化]
    C --> D[DXE Phase<br/>ドライバ実行環境]
    D --> E[BDS Phase<br/>ブート選択]
    E --> F[OS Loader<br/>OS起動]

    style A fill:#f9f,stroke:#333
    style F fill:#9f9,stroke:#333
\```
```

---

## 💡 コラムの執筆ガイドライン

### コラムの目的と位置づけ

コラムは、本文の理解を深め、読者の知識を広げるための**オプショナルなコンテンツ**です。本文は体系的な学習に必須ですが、コラムは興味のある読者のみが読めば良い補足情報として位置づけます。

**主な目的**:
- 本文で扱った技術の背景や歴史を知ることで、理解を深める
- 実務での経験やトラブル事例を共有し、実践的な知識を提供する
- 発展的な内容や関連技術を紹介し、読者の興味を広げる
- 技術的な深堀りや裏話を提供し、より深い理解を促す

**本文との違い**:
- 本文: 体系的・必須の知識（読まないと次の章が理解できない）
- コラム: 補足的・発展的な内容（読まなくても学習は進められる）

---

### コラムの種類（8タイプ）

コラムは以下の8種類に分類され、それぞれ異なるアイコンで識別します。

#### 1. 🕰️ 歴史的エピソード

技術の誕生や発展の背景を紹介します。

**例**:
- Intel 8086の開発秘話
- BIOS から UEFI への移行の歴史
- レガシーBIOSが20年以上生き残った理由

**トーン**: 読み物として楽しめる、歴史的事実に基づく

---

#### 2. 💼 実務での事例

実際のプロジェクトや現場での経験を共有します。

**例**:
- ファームウェア更新失敗によるブリック事例と回復方法
- 量産前に発見された致命的なバグの話
- デバッグに3日かかった難解なバグとその原因

**トーン**: 実践的、教訓を含む、失敗談も歓迎

---

#### 3. 🔬 技術的深堀り

本文で扱った技術をさらに深く掘り下げます。

**例**:
- なぜx86はリトルエンディアンを採用したのか
- UEFI変数の内部実装とフラッシュレイアウト
- Secure Bootの暗号アルゴリズムの詳細

**トーン**: やや高度、数式や詳細な実装を含む

---

#### 4. 🔒 セキュリティ事例

実際のセキュリティ脆弱性や攻撃手法を紹介します。

**例**:
- Meltdown/Spectreとファームウェアの対応
- BootKitの仕組みと対策
- Intel MEの脆弱性CVE-XXXX-YYYY

**トーン**: 教育的、倫理的配慮を含む、CVE番号明記

---

#### 5. 🛠️ 開発ツールTips

効率的な開発やデバッグのテクニックを共有します。

**例**:
- gdbでUEFIをステップ実行するための設定
- シリアルデバッグ出力の活用術
- QEMUの便利なオプション

**トーン**: 実用的、コマンド例を含む

---

#### 6. 👥 コミュニティの話

オープンソースコミュニティや開発者の話を紹介します。

**例**:
- corebootプロジェクトの誕生と成長
- EDK IIメーリングリストでの議論
- OSFC（Open Source Firmware Conference）の見どころ

**トーン**: 親しみやすい、コミュニティ参加を促す

---

#### 7. 📜 規格の裏話

仕様策定の経緯や設計判断の背景を説明します。

**例**:
- UEFI規格が複雑になった理由
- ACPIテーブルのバージョンアップの歴史
- なぜUEFI Secure Bootは複雑なのか

**トーン**: 技術政治的な背景を含む、中立的

---

#### 8. 🏢 ベンダー固有の話

特定ベンダーの実装や特徴を紹介します。

**例**:
- AMI vs Insyde vs Phoenix BIOSの違い
- Intel Management Engine (ME) の役割
- Apple T2チップの独自ファームウェア

**トーン**: 比較的中立、特定ベンダーを不当に批判しない

---

### コラムのフォーマット

```markdown
---

## 💡 コラム: [簡潔なタイトル（20文字以内）]

[アイコンを冒頭に配置]

[導入段落: なぜこのトピックが興味深いのか、本文とどう関連するのかを説明（2-3文）]

[本文: 4-6段落で詳しく説明]

第1段落: 背景や概要
第2段落: 詳細な説明（技術的内容、事例など）
第3段落: さらなる詳細や補足
第4段落: 影響や意義
（第5-6段落: 必要に応じて追加）

[結び段落: まとめ、本文への関連性、さらに学ぶためのヒント（2-3文）]

**参考資料** （オプション）:
- [リンク1](URL)
- [リンク2](URL)

---
```

#### フォーマットの詳細ルール

1. **タイトル**:
   - 簡潔で内容を的確に表す
   - 20文字以内を目安
   - 疑問形も可（例: 「なぜx86はリトルエンディアンなのか？」）

2. **長さ**:
   - 4-6段落を基本とする
   - 1段落は3-6文
   - 全体で300-500字程度（短すぎず長すぎず）

3. **トーン**:
   - 本文よりやや砕けた語調
   - ただし技術的な正確性は維持
   - 個人的な経験や意見を含めても良い

4. **引用**:
   - 事実に基づく内容
   - 出典が明確な場合は参考資料として明記
   - CVE番号、仕様書のセクション番号などを含める

---

### コラムの配置ルール

#### 配置位置

1. **セクション間**: 本文の主要セクションの後
2. **演習の前**: 演習・まとめセクションの前に配置
3. **関連性**: コラムの内容と直前のセクションが関連していること

**配置例**:

```
## はじめに
[本文]

## セクション1: 技術解説
[本文]

---
## 💡 コラム: 関連する深堀りトピック
[コラム内容]
---

## セクション2: 実装例
[本文]

## まとめ
[本文]
```

#### 配置数量

- **1章あたり**: 0-2個まで
  - 章の長さや内容に応じて調整
  - すべての章にコラムが必要なわけではない

- **全体**: 60章で30-50個程度を目安
  - Part 0-I: 5-10個（初心者向け、歴史的背景や動機付け）
  - Part II-III: 15-20個（実装事例、Tips）
  - Part IV-V: 10-15個（セキュリティ事例、デバッグTips）
  - Part VI: 5-10個（発展的内容、他アーキテクチャ比較）

#### 配置判断基準

**コラムを配置すべき場合**:
- 本文で扱った技術に興味深い歴史や背景がある
- 実務での重要な教訓やトラブル事例がある
- 発展的な内容で読者の興味を広げられる
- セキュリティ上重要な事例がある

**コラムを配置すべきでない場合**:
- 本文の理解に必須の内容（本文に含めるべき）
- 関連性が薄い内容
- 章が既に十分長い場合

---

### コラムの品質基準

#### 内容の質

1. **正確性**: 技術的に正確な情報
2. **関連性**: 本文の内容と明確に関連
3. **独自性**: 単なる本文の繰り返しではない新しい視点
4. **興味深さ**: 読者の好奇心を刺激する

#### 文章の質

1. **読みやすさ**: 平易な日本語、適切な段落分け
2. **具体性**: 抽象的な説明より具体例を重視
3. **バランス**: 長すぎず短すぎず（300-500字）
4. **結論**: 明確なまとめや教訓を含む

#### 技術的な質

1. **出典明示**: 事実に基づく場合は出典を明記
2. **バージョン情報**: ソフトウェア・仕様のバージョンを明記
3. **中立性**: 特定のベンダーを不当に批判しない
4. **倫理性**: セキュリティ情報は教育目的に限定

---

### コラムの具体例

#### 例1: Part I での歴史的エピソード

```markdown
---

## 💡 コラム: Intel 8086 の開発秘話

🕰️ **歴史的エピソード**

1978年、Intel が 8086 を発表したとき、実は 8ビットの 8080 との互換性を保つために、16ビットなのに「86」という名前が選ばれました。なぜこの設計判断が行われ、それが今日の x86_64 アーキテクチャにどう影響したのでしょうか。

8086 の設計チームは、既存の 8080 ユーザーが容易に移行できるよう、レジスタ名やアセンブリ構文に互換性を持たせる方針を取りました。AX、BX、CX、DX という汎用レジスタは、8080 の A、B、C、D レジスタの拡張版として設計されています。この決定により、既存の 8080 用アセンブラやプログラマが比較的スムーズに 16ビットへ移行できました。

さらに興味深いのは、リトルエンディアン（下位バイトを先に配置）の採用です。これは 8080 がリトルエンディアンだったため、互換性のために踏襲されました。この設計判断は、40年以上経った今でも x86_64 アーキテクチャに引き継がれており、メモリダンプを読む際に「なぜ逆順なのか」と混乱する初心者を生み出し続けています。

8086 のもう一つの重要な遺産は、セグメント方式のメモリ管理です。20ビットのアドレス空間（1 MB）を 16ビットレジスタで扱うため、セグメントレジスタ（CS、DS、SS、ES）を導入しました。この方式は、後のプロテクトモードやロングモードでも形を変えて残り、現代の UEFI ファームウェアでも GDT（Global Descriptor Table）として扱う必要があります。

この「互換性を重視した設計」という Intel の哲学は、その後の 80286（プロテクトモード）、80386（32ビット）、そして AMD64（64ビット）へと受け継がれ、x86 アーキテクチャの複雑さの源泉となっています。しかし同時に、この互換性こそが x86 を 40年以上にわたって市場の主流に保ち続けた理由でもあります。

本章で学ぶリセットベクタやリアルモードの仕組みは、まさにこの 8086 の設計判断の直系の子孫です。歴史を知ることで、「なぜこんな複雑な仕組みなのか」という疑問が「なるほど、互換性のためか」という理解に変わるはずです。

**参考資料**:
- [Intel 8086 Datasheet (1978)](https://en.wikipedia.org/wiki/Intel_8086)
- [The 8086 Family User's Manual](http://bitsavers.org/components/intel/8086/)

---
```

#### 例2: Part III での実務事例

```markdown
---

## 💡 コラム: ファームウェア更新失敗でブリックした100台のサーバ

💼 **実務での事例**

ある企業で、データセンターの100台のサーバに対してファームウェア更新を一斉実施したところ、更新中に停電が発生し、全てのサーバがブリック（起動不能）状態になった事例があります。この事例から、ファームウェア更新の重要な教訓を学びましょう。

事の発端は、セキュリティパッチを適用するための BIOS 更新でした。管理者は、ベンダー提供の更新ツールを使用し、深夜のメンテナンス時間帯に一斉更新を実施しました。ところが、更新開始から10分後、データセンターの一部で瞬断が発生し、UPS（無停電電源装置）の容量を超えて電源が落ちてしまいました。

翌朝、現場に駆けつけたエンジニアが目にしたのは、POST 画面すら表示されない100台のサーバでした。ファームウェアが更新中に破損し、CPU が実行すべきコードが存在しない状態、いわゆる「ブリック」です。通常の手段では復旧できず、全てのサーバマザーボードを一時撤去し、専用のプログラマでフラッシュ ROM を書き直す必要がありました。復旧には3日間を要し、ダウンタイムによる損失は数千万円に上りました。

この事例から得られる教訓は、**ファームウェア更新には必ずフェールセーフ機構が必要**だということです。現代のサーバファームウェアでは、Dual BIOS（2つのフラッシュ ROM を搭載し、片方が失敗してももう片方から起動）や、Boot Block（更新されない最小限の起動コード）といった保護機構が一般的です。また、更新は必ず段階的に実施し（例: 10台ずつ）、万が一の失敗に備えるべきです。

さらに重要なのは、BMC（Baseboard Management Controller）や IPMI（Intelligent Platform Management Interface）を活用したリモート復旧手段を確保しておくことです。これらの機能を使えば、物理的にアクセスせずともファームウェアを再書き込みできる場合があります。

本章で学ぶ PEI Phase でのプラットフォーム初期化は、このような障害からの復旧シナリオも考慮して設計されています。Boot Block が最小限のハードウェア初期化を行い、復旧モードに入る仕組みを理解することで、より堅牢なファームウェア設計ができるようになります。

---
```

#### 例3: Part VI での技術的深堀り

```markdown
---

## 💡 コラム: なぜ coreboot は高速起動できるのか

🔬 **技術的深堀り**

coreboot が UEFI ファームウェアよりも圧倒的に高速に起動できる理由は、単に「コードが小さい」だけではありません。その背後には、ブートプロセスに対する根本的に異なる設計思想があります。

従来の BIOS/UEFI は「すべてのハードウェアを初期化し、あらゆる OS に対応できる汎用的な環境を提供する」という思想で設計されています。そのため、PCI デバイスの列挙、Option ROM の実行、ACPI テーブルの生成、UEFI ドライバのロードといった、多数の処理を順番に実行します。特に UEFI は、DXE Phase で数十から数百のドライバをロードし、それぞれが依存関係に基づいて初期化されるため、どうしても時間がかかります。

一方、coreboot は「最小限のハードウェア初期化のみを行い、OS 起動に必要な処理は Payload に委譲する」という思想です。具体的には、CPU、メモリコントローラ、シリアルポートといった起動に絶対必要なコンポーネントのみを初期化し、それ以外（例: USB コントローラ、グラフィックカード）は Linux カーネルに初期化を任せます。この分業により、ファームウェアのコードサイズは 512 KB 程度に抑えられ、起動時間も 1秒未満を実現できます。

さらに、coreboot は並列初期化を積極的に活用します。例えば、メモリトレーニング（DRAM の最適なタイミング設定を見つける処理、通常 1-2秒かかる）と並行して、フラッシュ ROM から Payload を読み込むことで、全体の起動時間を短縮します。UEFI の逐次的な Phase 遷移（SEC → PEI → DXE → BDS）とは対照的です。

ただし、この高速性にはトレードオフがあります。coreboot は特定のハードウェア構成に最適化されるため、汎用性が低くなります。異なるマザーボードごとにビルドが必要であり、Windows のような UEFI に依存する OS は直接起動できません（UEFI Payload 経由なら可能）。また、ハードウェアベンダーが提供する初期化コード（例: Intel FSP）に依存する部分もあり、完全なオープンソース化は困難な場合があります。

coreboot の設計思想は、Google Chromebook のように「特定の OS（Chrome OS / Linux）を高速に起動する」という要件には最適です。本章で学ぶ coreboot の実装を通じて、ファームウェア設計における「汎用性 vs 最適化」のトレードオフを深く理解できるでしょう。

**参考資料**:
- [coreboot Performance Analysis](https://doc.coreboot.org/)
- [Linux Kernel Boot Time Optimization](https://elinux.org/Boot_Time)

---
```

---

### ユーザーからの指示に基づく執筆

コラムは、**ユーザーからの明示的な指示に基づいて執筆**します。自発的にコラムを追加するのではなく、ユーザーが以下の形式で指示する場合に執筆を開始します。

**指示の形式例**:
- 「Part I Chapter 2 に、8086 の歴史的背景についてのコラムを追加して」
- 「Part III Chapter 5 に、実務でのファームウェア更新失敗事例のコラムを書いて」
- 「Part VI Chapter 3 に、coreboot の高速起動の技術的深堀りを追加して」

**執筆プロセス**:
1. ユーザーの指示を確認（Part、Chapter、トピック、コラムタイプ）
2. 該当章の内容を確認し、最適な配置位置を決定
3. 上記のフォーマットとガイドラインに従ってコラムを執筆
4. 品質基準を満たしているか確認
5. 章の該当箇所に挿入

---

## 🎯 各Partの執筆方針

### Part 0: BIOS/UEFIの全体像

**目標**: BIOS/UEFIの役割とファームウェアエコシステムの全体像を理解する

**重点**:
- 本書の目的と構成の説明
- BIOS/UEFIの歴史的経緯と存在意義
- ファームウェアエコシステム全体（ツール、仕様、コミュニティ）
- 学習環境の位置づけ（なぜQEMU、EDK IIを使うか）

**執筆時の注意**:
- 「なぜファームウェアが必要か」を文章で丁寧に説明する
- 全体の見取り図を文章で提供し、必要に応じて補足図を使う
- 環境構築の詳細は避け、ツールの目的を段落で説明
- 読者のモチベーションを高める文章を心がける
- 箇条書きは学習目標など最小限にとどめる

**章の構成**:
1. 本書のゴールと学習ロードマップ
2. BIOS/UEFIとは何か：歴史と役割
3. ファームウェアエコシステム全体像
4. 学習環境の概要とツールの位置づけ
5. Part 0 まとめ

### Part I: x86_64 ブート基礎：CPUとメモリ

**目標**: x86_64 アーキテクチャにおけるブートプロセスの全体像を理解する

**重点**:
- リセットから最初の命令実行までの流れ
- メモリマップの構造と目的
- CPU モード遷移の仕組みと理由
- UEFI ブートフェーズの役割分担
- 図解を多用して流れを可視化

**執筆時の注意**:
- 「なぜそうなっているか」を文章で詳しく説明する
- 実モード→プロテクトモード→ロングモードの遷移理由を段落で説明
- GDT/IDT の目的と役割を文章で明確に説明し、必要に応じて補足図を使う
- Intel/AMD のマニュアル参照箇所を明記
- UEFI 仕様書の該当セクションを明記
- 図解は文章の理解を助けるための補助として最小限に

**章の構成**:
1. リセットから最初の命令まで
2. メモリマップと E820
3. CPU モード遷移の全体像
4. 割り込みとタイマの仕組み
5. UEFI ブートフェーズの全体像
6. 各ブートフェーズの役割と責務
7. Part I まとめ

### Part II: EDK II アーキテクチャ

**目標**: EDK II の設計思想とアーキテクチャを理解する

**重点**:
- EDK II の全体構成と設計思想
- モジュール、プロトコル、ライブラリの役割
- ビルドシステムの仕組み（INF/DEC/DSC の目的）
- 各コンポーネントの責務と連携

**執筆時の注意**:
- 「なぜこのような設計になっているか」を文章で重点的に説明する
- コード例は概念を示すための最小限の例に留め、文章で説明する
- 実装手順よりも、アーキテクチャの理解を段落での説明で深める
- 図解は必要最小限にし、文章での説明を充実させる
- 各コンポーネントの役割と連携を文章で丁寧に解説する

**章の構成**:
1. EDK II の設計思想と全体構成
2. モジュール構造とビルドシステム
3. プロトコルとドライバモデル
4. ライブラリアーキテクチャ
5. ハードウェア抽象化の仕組み
6. グラフィックスサブシステム (GOP)
7. ストレージスタックの構造
8. USB スタックの構造
9. ブートマネージャとブートローダの役割
10. Part II まとめ

### Part III: プラットフォーム初期化の仕組み

**目標**: プラットフォーム初期化の流れと各コンポーネントの役割を理解する

**重点**:
- PEI フェーズの役割と構造
- DRAM 初期化の仕組みと重要性
- CPU、チップセット、PCH/SoC の初期化順序と理由
- PCIe の仕組みとデバイス列挙
- ACPI の目的と構造
- SMBIOS、MP テーブルの役割

**執筆時の注意**:
- 各コンポーネントが「なぜ必要か」を文章で丁寧に説明する
- FSP/AGESA の役割と位置づけを段落で明確に説明
- 実装の詳細よりも、仕組みと設計思想を文章で重視
- ACPI 仕様書の該当セクション参照を明記
- 図解は補助的に使用し、文章での説明を主体とする
- 初期化の流れを段落で順序立てて説明する

**章の構成**:
1. PEI フェーズの役割と構造
2. DRAM 初期化の仕組み
3. CPU とチップセット初期化
4. PCH/SoC の役割と初期化
5. PCIe の仕組みとデバイス列挙
6. ACPI の目的と構造
7. ACPI テーブルの役割
8. SMBIOS と MP テーブルの役割
9. Part III まとめ

### Part IV: セキュリティアーキテクチャ

**目標**: UEFI セキュリティの仕組みと設計思想を理解する

**重点**:
- ファームウェアセキュリティ全体像
- 信頼チェーンの構築方法
- Secure Boot のアーキテクチャ
- TPM の役割と Measured Boot
- ベンダー固有のセキュリティ機構（Boot Guard、PSP）
- SPI フラッシュ保護、SMM セキュリティ
- 実際の攻撃事例から学ぶ設計原則

**執筆時の注意**:
- 「なぜこのセキュリティ機構が必要か」を文章で明確に説明する
- 信頼チェーンの構築方法を段落で詳しく説明し、必要に応じて補足図を使う
- CVE 事例から設計の教訓を文章で抽出し、段落で解説
- 倫理的配慮（攻撃手法は教育目的のみ）を文章で説明
- セキュリティのトレードオフを段落で丁寧に説明する

**章の構成**:
1. ファームウェアセキュリティの全体像
2. 信頼チェーンの構築
3. UEFI Secure Boot の仕組み
4. TPM と Measured Boot
5. Intel Boot Guard の役割と仕組み
6. AMD PSP の役割と仕組み
7. SPI フラッシュ保護機構
8. SMM の仕組みとセキュリティ
9. 攻撃事例から学ぶ設計原則
10. Part IV まとめ

### Part V: デバッグと最適化の原理

**目標**: デバッグ手法の原理と最適化の考え方を理解する

**重点**:
- ファームウェアデバッグの基本原理
- デバッグツールの仕組み（gdb、シリアルコンソールなど）
- 典型的な問題パターンと原因
- ログとトレースの設計思想
- パフォーマンス測定の原理
- ブート時間最適化の考え方
- 電源管理の仕組み
- ファームウェア更新の仕組み

**執筆時の注意**:
- ツールの使い方よりも、「なぜそうなっているか」を文章で説明する
- 問題パターンと根本原因の関係を段落で明確に説明
- 最適化のトレードオフを文章で丁寧に説明
- ログ設計の原則を段落で示す
- デバッグ手法の理論的背景を文章で解説する

**章の構成**:
1. ファームウェアデバッグの基礎
2. デバッグツールの仕組み
3. 典型的な問題パターンと原因
4. ログとトレースの設計
5. パフォーマンス測定の原理
6. ブート時間最適化の考え方
7. 電源管理の仕組み (S3/Modern Standby)
8. ファームウェア更新の仕組み
9. Part V まとめ

### Part VI: 他のファームウェア実装と発展

**目標**: 他のファームウェア実装・アーキテクチャの設計思想を理解する

**重点**:
- ファームウェアの多様性とその理由
- coreboot の設計哲学と EDK II との比較
- レガシー BIOS アーキテクチャ
- ネットワークブートの仕組み
- プラットフォーム別の特性（サーバ/組込み/モバイル）
- ARM64 ブートアーキテクチャと x86 との違い
- ファームウェアの将来展望

**執筆時の注意**:
- 実装よりも設計思想の比較を文章で重視
- 「なぜ異なる設計が選ばれたか」を段落で丁寧に説明
- Device Tree の目的と x86 との違いを文章で詳しく説明
- 各プラットフォームの要件の違いを段落で明確に説明
- 将来の技術動向を文章で考察する
- 比較は表に頼らず、文章で説明することを優先する

**章の構成**:
1. ファームウェアの多様性
2. coreboot の設計思想
3. coreboot と EDK II の比較
4. レガシー BIOS アーキテクチャ
5. ネットワークブートの仕組み
6. プラットフォーム別の特性：サーバ/組込み/モバイル
7. ARM64 ブートアーキテクチャ
8. ARM と x86 の違い
9. ファームウェアの将来展望
10. Part VI まとめ

---

## ✅ 品質チェックリスト

### 各章完成時の確認項目

#### 文章の質

- [ ] 各セクションが文章の段落で構成されている（箇条書き主体ではない）
- [ ] 各段落が3-6文で構成され、1つの概念を完結させている
- [ ] 段落間の接続詞が適切に使用されている（まず、次に、さらに、など）
- [ ] 導入部で何を説明するかが明示されている
- [ ] 専門用語の初出時に文章で説明がある

#### 内容の充実度

- [ ] 🎯 学習目標が明記されている
- [ ] 📚 前提知識が明記されている
- [ ] 概要と目的が文章で説明されている（2-4段落）
- [ ] 全体構成が文章で説明されている（3-5段落）
- [ ] 動作原理・仕組みが文章で詳細に説明されている（4-6段落）
- [ ] 設計思想・目的が文章で説明されている（3-5段落）
- [ ] コンポーネントの役割が文章で明確に説明されている
- [ ] まとめセクションで要約が文章で記述されている（2-3段落）

#### 図表の適切性

- [ ] 図表は文章の説明の後に配置されている
- [ ] 図表の前に導入文がある（「以下の図は〜」）
- [ ] 図表は補助的な役割に徹している（文章が主体）
- [ ] 図表の数が適切である（1セクション0-1個程度）
- [ ] 箇条書きは最小限に抑えられている（まとめ等のみ）

#### その他

- [ ] 参考資料へのリンクがある
- [ ] 誤字脱字がない
- [ ] リンク切れがない

### コード例の確認（該当する場合）

- [ ] コードの目的が明記されている
- [ ] 概念を理解するために必要な部分のみを抽出している
- [ ] 簡潔で読みやすい（完全なコードである必要はない）
- [ ] 重要な箇所にコメントがある

### リンク・参照の整合性

- [ ] 用語集へのリンクが正しい
- [ ] 他章への参照が正しい
- [ ] 外部リンクが有効
- [ ] UEFI 仕様書の参照が正確

---

## 📊 進捗管理

### 章の完成度マーカー

各章のファイル先頭に以下を記載：

```markdown
<!-- Status: draft | in-review | completed -->
<!-- Last Updated: YYYY-MM-DD -->
<!-- Word Count: XXXX -->
```

### 完成度の定義

| Status | 説明 | 次のアクション |
|--------|------|---------------|
| `draft` | 執筆中 | 執筆を継続 |
| `in-review` | レビュー待ち | レビュー・修正 |
| `completed` | 完成 | なし |

### 未執筆章のプレースホルダー

現在、多くの章が以下のプレースホルダー状態：

```markdown
# 章タイトル

（執筆予定）
```

執筆時は必ずこのプレースホルダーを削除し、完全な章に置き換える。

---

## 📚 参考資料リスト

### 必読仕様書

1. **UEFI Specification**
   - https://uefi.org/specifications
   - 最新版を参照（執筆時点で v2.10）

2. **ACPI Specification**
   - https://uefi.org/specifications
   - ACPI 6.5 以降

3. **Intel® 64 and IA-32 Architectures Software Developer Manuals**
   - https://www.intel.com/sdm
   - Volume 3: System Programming Guide

4. **AMD64 Architecture Programmer's Manual**
   - https://www.amd.com/en/support/tech-docs

### EDK II ドキュメント

1. **EDK II Documentation**
   - https://github.com/tianocore/tianocore.github.io/wiki

2. **EDK II Module Writer's Guide**
   - https://tianocore-docs.github.io/edk2-ModuleWriteGuide/

3. **EDK II Build Specification**
   - https://tianocore-docs.github.io/edk2-BuildSpecification/

### coreboot

1. **coreboot Documentation**
   - https://doc.coreboot.org/

2. **coreboot Developer Manual**
   - https://doc.coreboot.org/getting_started/index.html

### コミュニティ

1. **TianoCore (EDK II)**
   - Mailing List: https://edk2.groups.io/
   - GitHub: https://github.com/tianocore/edk2

2. **coreboot**
   - IRC: #coreboot on libera.chat
   - Mailing List: https://www.coreboot.org/Mailinglist

3. **UEFI Forum**
   - https://uefi.org/

---

## 🚀 執筆開始手順

### Step 1: 最初の章を選ぶ

推奨順序:
1. **Part 0 の第1章** (`src/part0/01-goals-and-roadmap.md`) - 本書の目的と構成
2. **Part 0 の第2章** (`src/part0/02-what-is-bios-uefi.md`) - BIOS/UEFIの基本概念
3. その後、Part 0 → Part I → Part II の順に進める

### Step 2: 章を執筆

1. プレースホルダーを削除
2. 上記テンプレートに従って執筆
3. **文章を先に執筆**（全体像を段落で説明）
4. 目的・構成・仕組み・役割の順に、各セクションを文章で執筆
5. 文章での説明が完了した後、必要に応じて補足図を追加
6. 図表の前に必ず導入文を追加
7. 品質チェックリスト確認（特に文章の質をチェック）

**重要**: 図表から書き始めず、必ず文章から執筆を開始すること

### Step 3: ビルド確認

```bash
mdbook build
mdbook serve
```

ブラウザで確認し、レイアウト・リンクをチェック

### Step 4: コミット

```bash
git add src/partX/YY-chapter-name.md
git commit -m "完成: Part X - 章タイトル"
git push
```

### Step 5: 次の章へ

Part 0 → Part I → Part II... の順に進める

---

## 📝 執筆時のよくある質問

### Q1: コード例はどこまで詳しく書くべき？

A: **概念を理解するための最小限のコード**を提供します：
- 完全に動作する必要はない（概念を示すための疑似コードでも可）
- 重要な部分のみを抽出・簡略化
- 目的を明記し、「実際の実装は異なる場合がある」と注記

### Q2: 図表はどう使うべき？

A: **文章が主体、図表は補助**です：
1. まず文章で丁寧に説明する（2-6段落）
2. 図表は文章の理解を助けるために必要な場合のみ使用
3. 図表の前に必ず導入文を置く（「以下の図は〜」）
4. 図表の種類:
   - Mermaid - 複雑な構造や流れの場合のみ
   - 表 - 5項目以上の比較の場合のみ
   - ASCII art - メモリレイアウトなど視覚化が有効な場合のみ
5. 箇条書きは最小限にし、段落での説明を優先

### Q3: 実装手順とアーキテクチャ解説のバランスは？

A: **アーキテクチャ解説を文章で優先**します：
- 「どうやるか」より「なぜそうなっているか」を段落で重視
- 実装手順は参考程度に留める
- 設計思想、目的、役割を文章で段階的に説明
- 箇条書きに頼らず、接続詞を使って論理的に展開

### Q4: 専門用語はどこまで説明する？

A: **初出時に必ず説明**し、用語集にも追加します。

### Q5: 参考文献のフォーマットは？

A:
```markdown
📚 **参考資料**
- [UEFI Specification v2.10 - Section X.Y](https://uefi.org/specifications)
- [Intel SDM Volume 3 - Chapter Z](https://www.intel.com/sdm)
```

仕様書の該当セクションまで明記します。

### Q6: 他の章への参照方法は？

A:
```markdown
詳細は [Part I: リセットから最初の命令まで](../part1/01-reset-vector.md) を参照してください。
```

---

## 🎯 執筆の最終目標

### 完成基準

- [ ] 全60章が `completed` 状態
- [ ] すべての章が文章主体で執筆されている（箇条書きは最小限）
- [ ] 各章が適切な段落構成になっている（1段落3-6文）
- [ ] 目的・構成・仕組み・役割が文章で明確に説明されている
- [ ] 図表は補助的な役割に徹している（文章の後に配置）
- [ ] 図表の前に必ず導入文がある
- [ ] 用語集が網羅的
- [ ] 付録が充実
- [ ] mdbook build がエラーなく完了
- [ ] GitHub Pages で正常に表示

### 読者が得られる成果

**本書を読み終えた読者は：**

1. ✅ BIOS/UEFI の全体像とブートプロセスを理解している
2. ✅ EDK II のアーキテクチャと設計思想を理解している
3. ✅ プラットフォーム初期化の流れと各フェーズの役割を理解している
4. ✅ セキュリティ機構の仕組みと設計原則を理解している
5. ✅ 他のファームウェア実装（coreboot等）との違いを理解している
6. ✅ BIOS/UEFI 開発者として必要な知識体系を獲得している

---

**Happy Writing! 📝**
