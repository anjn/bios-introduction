# レガシー BIOS アーキテクチャ

🎯 **この章で学ぶこと**
- レガシーBIOSの基本アーキテクチャ
- INT 10h, INT 13h等のBIOS割り込みサービス
- MBRブートとパーティションテーブル
- UEFIとの互換性層(CSM)

📚 **前提知識**
- [Part I: x86_64 ブート基礎](../part1/01-reset-vector.md)

---

## はじめに

**レガシー BIOS**（Basic Input/Output System）は、1980 年代から続く **x86 PC の伝統的なファームウェアシステム**であり、IBM PC の時代から 30 年以上にわたって PC プラットフォームの標準として君臨してきました。本書ではこれまで UEFI と EDK II、そして coreboot といった現代のファームウェアシステムを学んできましたが、レガシー BIOS を理解することは、ファームウェアの歴史的進化を知り、現代のファームウェアが解決しようとしている問題を理解するために不可欠です。また、レガシー BIOS の設計原則とインターフェースは、今でも互換性層（CSM: Compatibility Support Module）として UEFI ファームウェアに組み込まれており、実務上の重要性も失われていません。

**レガシー BIOS の核心**は、**16 ビットリアルモードで動作する割り込みベースのサービス群**です。BIOS は ROM に格納された小さなプログラム（128 KB から 2 MB）であり、電源投入後に POST（Power-On Self Test）を実行してハードウェアの基本動作を確認し、次に INT 10h（ビデオサービス）、INT 13h（ディスクサービス）、INT 15h（システムサービス）、INT 16h（キーボードサービス）といった**BIOS 割り込みサービス**を提供します。OS ローダやブートローダは、これらの割り込みサービスを呼び出すことで、ハードウェアに依存しない方法で画面表示、ディスク読み書き、キーボード入力を実行できます。この抽象化により、OS やアプリケーションはハードウェアの詳細を知る必要がなく、BIOS が提供する標準インターフェースを使用するだけで済みます。

**MBR（Master Boot Record）ブート**は、レガシー BIOS のブート方式です。BIOS は、ブートデバイス（通常はハードディスク）の最初のセクタ（512 バイト）を読み込み、それをメモリの 0x7C00 番地にロードして実行します。この最初のセクタが MBR であり、446 バイトのブートコード、4 つのパーティションエントリ（各 16 バイト）、ブート署名（0x55AA）で構成されます。MBR のブートコードは、アクティブなパーティションを見つけ、そのパーティションのブートセクタ（VBR: Volume Boot Record）をロードして OS ローダに制御を渡します。この単純な仕組みにより、DOS、Windows、Linux といった多様な OS が同じブート手順を使用できました。

**レガシー BIOS の限界**は、現代のコンピューティング要件には対応しきれなくなっています。まず、**16 ビットリアルモード**という制約により、メモリは 1 MB までしかアクセスできず（実際には A0000-FFFFF は予約済みなので 640 KB）、32 ビットや 64 ビットの豊富なメモリ空間を活用できません。次に、**MBR パーティションテーブル**の制約により、ディスクサイズは最大 2 TB、パーティション数は最大 4 個に制限されます（拡張パーティションを使えば論理パーティションを増やせますが複雑）。さらに、**Secure Boot がない**ため、ブートプロセスの改ざんを検知できず、ブートキットやルートキットといったマルウェアに脆弱です。最後に、**拡張性が乏しい**ため、Option ROM（拡張カード上の BIOS）の実行は限定的であり、ネットワークブートも標準化されていません。

**CSM（Compatibility Support Module）** は、UEFI ファームウェアがレガシー BIOS をエミュレートする互換性層です。多くの UEFI ファームウェアは CSM を搭載しており、BIOS 割り込みサービスをエミュレートし、MBR ブートをサポートし、Option ROM を実行します。これにより、UEFI ファームウェア上で古い OS（Windows 7 以前、古い Linux ディストリビューション）や BIOS 専用のツール（診断ユーティリティ、バックアップソフトウェア）を実行できます。しかし、CSM を有効にすると Secure Boot が無効になるため、セキュリティとのトレードオフが生じます。Windows 10/11 は UEFI ネイティブブートを推奨しており、CSM への依存は徐々に減少しています。

この章では、レガシー BIOS の基本アーキテクチャ、BIOS 割り込みサービス（特に INT 10h と INT 13h）の仕組みと使い方、MBR ブートとパーティションテーブルの構造、CSM による UEFI との互換性、そしてレガシー BIOS の限界と UEFI への移行の必要性を学びます。歴史的な技術を学ぶことで、現代のファームウェアがなぜそのように設計されているのか、どのような問題を解決しようとしているのかを深く理解できます。

## レガシーBIOSとは

**レガシー BIOS** は、1980 年代から続く、x86 PC の伝統的なファームウェアシステムです。

### 基本構造

```
ROM BIOS (128KB - 2MB)
├── POST (Power-On Self Test)
├── BIOS INT サービス (INT 10h, 13h, 15h...)
├── Setup Utility
└── Boot Loader (MBR読み込み)
```

---

## BIOS割り込みサービス

### 主要な割り込み

| INT | 機能 | 用途 |
|-----|------|------|
| **INT 10h** | ビデオサービス | 画面表示、テキストモード |
| **INT 13h** | ディスクサービス | ディスク読み書き |
| **INT 15h** | システムサービス | メモリサイズ取得、APM |
| **INT 16h** | キーボードサービス | キー入力 |
| **INT 1Ah** | 時刻サービス | RTC読み取り |

### INT 13h の例

```asm
; ディスクから512バイト読み込み
mov ah, 02h         ; Read sectors
mov al, 01h         ; 1 sector
mov ch, 00h         ; Cylinder 0
mov cl, 01h         ; Sector 1
mov dh, 00h         ; Head 0
mov dl, 80h         ; Drive 0 (HDD)
mov bx, 7C00h       ; Buffer address
int 13h             ; BIOS call
jc  error           ; Carry flag = error
```

---

## MBRブート

### MBR (Master Boot Record) 構造

```
Offset  Size  Description
0x000   446   ブートコード
0x1BE   16    パーティションエントリ 1
0x1CE   16    パーティションエントリ 2
0x1DE   16    パーティションエントリ 3
0x1EE   16    パーティションエントリ 4
0x1FE   2     ブート署名 (0x55AA)
```

### ブートフロー

```
BIOS → MBR読み込み (0x7C00) → MBRコード実行 → OSローダ
```

---

## 💡 コラム: MBR の 512 バイト制限 - 40年続く設計上の制約と創意工夫

🕰️ **歴史的エピソード**

MBR（Master Boot Record）が **512 バイト**という厳しいサイズ制限を持つ理由は、1981 年の IBM PC 設計にまで遡ります。IBM PC の標準ストレージデバイスは 5.25 インチフロッピーディスクであり、そのセクタサイズが **512 バイト**でした。BIOS 設計者は、「ディスクの最初のセクタをメモリにロードして実行する」という最もシンプルな方法を採用しました。この決定は、当時のメモリ（数十 KB）と ROM（数 KB）が極めて限られていたため、合理的でした。しかし、この 512 バイトという制約は、その後 40 年以上にわたってブートローダ開発者を悩ませ続けることになります。

512 バイトのうち、実際にブートコードとして使えるのは **446 バイト**だけです。残りの 64 バイトはパーティションテーブル（4 エントリ × 16 バイト）、2 バイトはブート署名（0x55AA）に使われます。446 バイトで何ができるでしょうか？ ファイルシステムを解析し、カーネルを読み込み、メモリを初期化し、プロテクトモードに移行する——これらすべてを実装するには到底不可能です。このため、ブートローダは**多段階構成（Multi-stage Bootloader）** を採用せざるを得ませんでした。MBR に格納される **Stage 1** は、ディスクの固定位置にある **Stage 1.5** や **Stage 2** をロードする最小限のコードだけを含みます。

GRUB（GRand Unified Bootloader）の MBR コードは、まさにこの制約との戦いの産物です。GRUB の Stage 1（MBR コード）は、わずか 446 バイトで、**LBA（Logical Block Addressing）によるディスク読み込み**と **Stage 1.5 へのジャンプ**を実装します。Stage 1.5 は MBR と第1パーティションの間の隙間（通常 62 セクタ = 31 KB）に配置され、ファイルシステムドライバを含みます。このトリックにより、GRUB は ext2/3/4、FAT、NTFS といった複雑なファイルシステムをサポートできます。しかし、GPT ディスクでは、この「隙間」が標準化されていないため、GRUB は **BIOS Boot Partition** という専用パーティション（1 MB 程度）を必要とします。

446 バイトという制約は、ブートローダ開発者に**極限の最適化**を強いました。アセンブリ言語による手書き最適化、レジスタの徹底的な再利用、条件分岐の削減、文字列圧縮——こうしたテクニックが駆使されました。ある開発者は、「エラーメッセージを1文字削るために2時間かけた」と語っています。また、MBR コードは **16 ビットリアルモード**で実行されるため、メモリアクセスは 1 MB まで（実際には 640 KB まで）に制限され、ポインタ演算はセグメント:オフセット形式で行わなければなりません。このため、C言語で書かれたブートローダでも、MBR コード部分だけは純粋なアセンブリ言語で実装されることが多いのです。

**現代の視点**から見ると、512 バイト制限は時代遅れの制約です。UEFI の **ESP（EFI System Partition）** は、通常 100 MB 以上のサイズを持ち、ブートローダ（例: `BOOTX64.EFI`）は数百 KB から数 MB のサイズがあります。GPT（GUID Partition Table）は、128 個のパーティションエントリを持ち、各エントリは 128 バイトです。これにより、ブートローダは十分なコード量を持ち、GUI、ネットワークブート、暗号化ディスクのサポートといった高度な機能を実装できます。それでも、MBR の 512 バイト制限は、**互換性のために**今でも存在し続けています。レガシー BIOS をサポートする限り、この制約は消えることはありません。

512 バイトという小さな制約が、40 年間にわたってブートローダの設計と実装に影響を与え続けてきたという事実は、**初期の設計判断の重要性**を物語っています。一度標準化された仕様は、たとえ時代遅れになっても、互換性のために長く生き続けます。UEFI は、この歴史的制約から解放され、新しい可能性を開きました。しかし、MBR ブートを学ぶことで、限られたリソースの中で創意工夫を凝らす技術者の姿勢と、互換性維持の重要性を理解できるのです。

📚 **参考資料**
- [Master Boot Record - OSDev Wiki](https://wiki.osdev.org/MBR_(x86))
- [GRUB Boot Process](https://www.gnu.org/software/grub/manual/grub/html_node/Images.html)
- [IBM PC Technical Reference Manual (1981)](https://archive.org/details/IBM_5150_Technical_Reference_6025005_APR84)

---

## CSM (Compatibility Support Module)

UEFIファームウェアでレガシーBIOSをエミュレートします。

### CSMの役割

```
UEFI Firmware
  └── CSM Module
      ├── INT Handler エミュレーション
      ├── MBR Boot サポート
      └── Option ROM 実行
```

---

## レガシーBIOSの限界

| 項目 | レガシーBIOS | UEFI |
|------|-------------|------|
| ディスクサイズ | 2TB上限 (MBR) | 9.4ZB (GPT) |
| パーティション数 | 4個 | 128個 |
| ブートモード | 16ビットリアルモード | 32/64ビット |
| Secure Boot | なし | あり |
| ネットワークブート | 限定的 | 標準 |

---

## まとめ

この章では、**レガシー BIOS アーキテクチャ**の基本構造、BIOS 割り込みサービス、MBR ブート、CSM による UEFI との互換性、そしてレガシー BIOS の限界を学びました。レガシー BIOS は 30 年以上にわたって PC プラットフォームの標準として機能してきましたが、現代のコンピューティング要件には対応しきれず、UEFI への移行が進んでいます。

**レガシー BIOS の基本構造**は、ROM に格納された 128 KB から 2 MB のプログラムであり、POST（Power-On Self Test）、BIOS 割り込みサービス（INT 10h、INT 13h、INT 15h、INT 16h、INT 1Ah など）、Setup Utility、Boot Loader（MBR 読み込み）で構成されます。POST では、CPU、メモリ、ビデオカード、キーボード、ディスクといった基本的なハードウェアの動作確認を行い、エラーがあればビープ音やエラーコードで通知します。Setup Utility は、ユーザーがブート順序、日時、ハードウェア設定を変更するための UI を提供します。Boot Loader は、ブートデバイスの MBR を読み込んで実行します。

**BIOS 割り込みサービス**は、OS ローダやブートローダがハードウェアにアクセスするための標準インターフェースです。主要な割り込みとして、**INT 10h**（ビデオサービス）は画面表示とテキストモード制御を提供し、**INT 13h**（ディスクサービス）はディスクの読み書きを提供し、**INT 15h**（システムサービス）はメモリサイズ取得や APM（Advanced Power Management）を提供し、**INT 16h**（キーボードサービス）はキー入力を提供し、**INT 1Ah**（時刻サービス）は RTC（Real-Time Clock）の読み取りを提供します。これらの割り込みは、16 ビットリアルモードで動作し、レジスタを介してパラメータを渡します。例えば、INT 13h でディスクから 1 セクタ（512 バイト）を読み込むには、AH=02h（Read sectors）、AL=01h（1 sector）、CH=00h（Cylinder 0）、CL=01h（Sector 1）、DH=00h（Head 0）、DL=80h（Drive 0 for HDD）、BX=7C00h（Buffer address）を設定して INT 13h を呼び出します。キャリーフラグがセットされればエラーです。

**MBR（Master Boot Record）ブート**は、レガシー BIOS の標準的なブート方式です。MBR は、ブートデバイスの最初のセクタ（512 バイト、LBA 0）に配置され、オフセット 0x000 から 446 バイトのブートコード、オフセット 0x1BE から 4 つのパーティションエントリ（各 16 バイト）、オフセット 0x1FE にブート署名（0x55AA）が格納されます。BIOS は、MBR を 0x7C00 番地にロードし、ブート署名（0x55AA）を確認してから 0x7C00 番地にジャンプします。MBR のブートコードは、パーティションテーブルを解析してアクティブなパーティション（ブートフラグ 0x80 がセットされているパーティション）を見つけ、そのパーティションの最初のセクタ（VBR: Volume Boot Record）を読み込んで実行します。VBR は OS 固有のブートローダ（GRUB、NTLDR、BOOTMGR など）をロードし、最終的に OS カーネルを起動します。このブートチェーン（BIOS → MBR → VBR → ブートローダ → OS カーネル）により、多様な OS が同じハードウェア上で起動できました。

**CSM（Compatibility Support Module）** は、UEFI ファームウェアがレガシー BIOS をエミュレートする互換性層です。UEFI ファームウェアは、CSM モジュールを搭載することで、INT Handler エミュレーション（INT 10h、INT 13h などの BIOS 割り込みサービスをエミュレート）、MBR Boot サポート（MBR パーティションテーブルを認識して MBR ブートを実行）、Option ROM 実行（拡張カード上の BIOS ROM を実行）を提供します。これにより、UEFI ファームウェア上で古い OS（Windows 7 以前、古い Linux ディストリビューション）や BIOS 専用のツール（診断ユーティリティ、バックアップソフトウェア）を実行できます。しかし、CSM を有効にすると Secure Boot が無効になるため、セキュリティとのトレードオフが生じます。多くの UEFI ファームウェアでは、Setup UI で CSM の有効/無効を切り替えられます。

**レガシー BIOS の限界**は、現代のコンピューティング要件と比較すると明確です。まず、**ディスクサイズの制限**として、MBR パーティションテーブルは 32 ビットの LBA（Logical Block Addressing）を使用するため、最大 2^32 セクタ × 512 バイト = 2 TB までしかサポートできません。これに対し、UEFI の GPT（GUID Partition Table）は 64 ビットの LBA を使用するため、最大 2^64 セクタ × 512 バイト = 9.4 ZB（ゼタバイト）をサポートします。次に、**パーティション数の制限**として、MBR は最大 4 つのプライマリパーティションしかサポートしません（拡張パーティションを使えば論理パーティションを増やせますが複雑です）。GPT は最大 128 個のパーティションをサポートします。さらに、**ブートモードの制約**として、レガシー BIOS は 16 ビットリアルモードで動作するため、メモリアクセスは 1 MB まで（実際には 640 KB）に制限され、32 ビットや 64 ビットの CPU 機能を活用できません。UEFI は 32 ビットまたは 64 ビットモードで動作し、豊富なメモリ空間を活用できます。また、**Secure Boot の欠如**により、レガシー BIOS ではブートプロセスの改ざんを検知できず、ブートキットやルートキットに脆弱です。UEFI は Secure Boot により、署名検証を通じてブートプロセスの完全性を保証します。最後に、**ネットワークブートの限定性**として、レガシー BIOS では PXE（Preboot eXecution Environment）の実装が限定的であり、標準化されていません。UEFI は PXE を標準サポートし、HTTP Boot などの新しいプロトコルも追加されています。

**UEFI への移行**は、これらの限界を克服するために不可欠です。Windows 10/11 は UEFI ネイティブブートを推奨し、Windows 11 では UEFI と TPM 2.0 が必須要件になりました。Linux ディストリビューションも UEFI ネイティブブートを標準サポートしています。CSM は過渡期の互換性層として重要ですが、長期的には廃止される方向です。Intel と Microsoft は、2020 年までに CSM のサポートを終了する計画を発表していましたが、実際には多くのファームウェアベンダーが CSM を継続してサポートしています。しかし、新規開発では UEFI ネイティブブートを前提とし、レガシー BIOS への依存を避けるべきです。

**歴史的意義**として、レガシー BIOS は 30 年以上にわたって PC プラットフォームの標準として機能し、PC の普及と発展に貢献しました。INT 13h、INT 10h といった BIOS 割り込みサービスは、ハードウェアの抽象化レイヤとして機能し、OS やアプリケーションがハードウェアの詳細を知る必要性を減らしました。MBR ブートは、シンプルで理解しやすいブート手順を提供し、多様な OS が共存できるマルチブート環境を可能にしました。レガシー BIOS の設計思想と実装は、現代のファームウェア（UEFI、coreboot）の設計にも影響を与えており、歴史を学ぶことで現代のファームウェアの意義を深く理解できます。

以下の参考表は、レガシー BIOS と UEFI の主要な違いをまとめたものです。

**参考表: レガシー BIOS と UEFI の比較**

| 項目 | レガシーBIOS | UEFI |
|------|-------------|------|
| ディスクサイズ | 2TB上限 (MBR) | 9.4ZB (GPT) |
| パーティション数 | 4個 | 128個 |
| ブートモード | 16ビットリアルモード | 32/64ビット |
| Secure Boot | なし | あり |
| ネットワークブート | 限定的 | 標準 |

---

次章: [Part VI Chapter 5: ネットワークブートの仕組み](05-network-boot.md)
